<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1446040724970">{:repl-history {:ide [], :local [&quot;(require 'clojure.xml)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :rss)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :link)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :link\n     print)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :content\n     print)&quot; &quot;(defn prime?\n  [n]\n  (cond\n    (== 1 n) false\n    (==2 n) true\n    (even? n) false\n    :else (-&gt;&gt; (range 3 (inc (Math/sqrt n)) 2)\n               (filter #(zero? (rem n %)))\n               empty?)))&quot; &quot;(defn prime?\n  [n]\n  (cond\n    (== 1 n) false\n    (== 2 n) true\n    (even? n) false\n    :else (-&gt;&gt; (range 3 (inc (Math/sqrt n)) 2)\n               (filter #(zero? (rem n %)))\n               empty?)))&quot; &quot;(prime? 14141)&quot; &quot;(prime? 5)&quot; &quot;(prime? 112589990)&quot; &quot;(prime? 1125899906842679)&quot; &quot;(time  (prime? 1125899906842679))&quot; &quot;(let [m-prime? (memoize prime?)])&quot; &quot;(time  (m-prime? 1125899906842679))&quot; &quot;(let [m-prime? (memoize prime?)]\n(time (m-prime? 1125899906842679)))&quot; &quot;(let [m-prime? (memoize prime?)]\n(time (m-prime? 1125899906842679))\n(time (m-prime? 1125899906842679)))&quot; &quot;(rand-int 1)&quot; &quot;(rand-int 2)&quot; &quot;(conj v 4)&quot; &quot;(conj v 4 5)&quot; &quot;(seq v)&quot; &quot;(def m {:a 4 :b 5})&quot; &quot;(conj s 4)&quot; &quot;(seq m)&quot; &quot;(conj m [:c 6])&quot; &quot;(seq s)&quot; &quot;#{2 1 3}&quot; &quot;#{1 2 3}&quot; &quot;(conj s 3 4)&quot; &quot;#{1 2 3 4}&quot; &quot;#{1 2 3 46}&quot; &quot;(def s #{1 3 4})&quot; &quot;(conj s 2)&quot; &quot;(def s #{1 2 3})&quot; &quot;(conj s 10)&quot; &quot;(seq lst)&quot; &quot;(conj lst 0 -1)&quot; &quot;(into v [4 5])&quot; &quot;(into v [3 4])&quot; &quot;(into m [[c: 7] [:d 8]])&quot; &quot;(into m [[:c 7] [:d 8]])&quot; &quot;(into s [3 4])&quot; &quot;(into  lst [4 5])&quot; &quot;(into  lst [[:a 1]] )&quot; &quot;(into  [1] [[:a 1]] )&quot; &quot;(conj v {:a 2})&quot; &quot;(into  [1] {:a 1} )&quot; &quot;(swap-pairs [1 2 4 5])&quot; &quot;(interleave\n          (take-nth 2 (drop 1 sequential))\n          (take-nth 2 sequential))&quot; &quot;(take-nth 2 sequential)&quot; &quot;(into (empty sequential)\n        (interleave\n          (take-nth 2 (drop 1 sequential))\n          (take-nth 2 sequential)))&quot; &quot;(defn swap-pairs\n  [sequential]\n  (into (empty sequential)\n        (interleave\n          (take-nth 2 (drop 1 sequential))\n          (take-nth 2 sequential))))&quot; &quot;(apply list (range 10))&quot; &quot;(swap-pairs (apply list (range 10)))&quot; &quot;(swap-pairs (apply vec (range 10)) )&quot; &quot;(swap-pairs (apply vector (range 10)))&quot; &quot;(swap-pairs (range 10))&quot; &quot;(take-nth 3 (range 10))&quot; &quot;(range 10)&quot; &quot;(take-nth 2 (range 10))&quot; &quot;(into (empty m)\n        (for [[k v] m] \n        [k (f v)]))&quot; &quot;(defn map-map\n  [f m]\n  (into (empty m)\n        (for [[k v] m] \n        [k (f v)])))&quot; &quot;(map-map inc {:a 1 :b 2})&quot; &quot;(map-map inc (sorted-map :a 3 :b 5))&quot; &quot;(map-map inc (hash-map :a 3 :b 5))&quot; &quot;(count (1 2 4 5))&quot; &quot;(count '(1 2 4 5))&quot; &quot;(count #(1 2 4 5))&quot; &quot;(count #{1 2 4 5})&quot; &quot;(count {:a 1 :b 2 :C 4 :d 5})&quot; &quot;(count [1 2 4 5])&quot; &quot;(dissoc m :a :c)&quot; &quot;(assoc v 3 \&quot;ddd\&quot;)&quot; &quot;(get #{1 2 4} 1)&quot; &quot;(get #{1 2 4} 3)&quot; &quot;(get #{1 2 4} 3 \&quot;not found!\&quot;)&quot; &quot;(if (get #{1 2 4} 3)\n  (print \&quot;it contains '3'\&quot;))&quot; &quot;(if (get #{1 2 4} 3)\n  (print \&quot;it contains '3'\&quot;)\n  (print \&quot;it doesn't contain '3'\&quot;))&quot; &quot;(def s #{1 2 4})&quot; &quot;(if (get s 3)\n  (print \&quot;it contains '3'\&quot;)\n  (print \&quot;it doesn't contain '3'\&quot;))&quot; &quot;(s 3)&quot; &quot;(s 1)&quot; &quot;(m :a)&quot; &quot;(m :b)&quot; &quot;(contains? m :c)&quot; &quot;(contains? v 4)&quot; &quot;(contains? v 1)&quot; &quot;(contains? v 2)&quot; &quot;(contains? v 0)&quot; &quot;:d&quot; &quot;(contains? m :d)&quot; &quot;(contains? s 3)&quot; &quot;(contains? v 3)&quot; &quot;(get \&quot;clojure\&quot; 3)&quot; &quot;(contains? (java.util.HashMap.) 1)&quot; &quot;(get (into-array [1 2 3]) 0)&quot; &quot;(get {:ethl nil} :ethl)&quot; &quot;(find {:ethl nil} :ethl)&quot; &quot;(find {:ethl nil} :r)&quot; &quot;(if-let [[k v] (find {:a 5 :b 6} :a)]\n  (format \&quot;found %s=&gt;%s\&quot; k v)\n  \&quot;not found\&quot;)&quot;], :remote []}}</component>
</project>