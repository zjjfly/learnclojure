<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1448444083849">{:repl-history {:ide [], :local [&quot;(magnitude 100)&quot; &quot;(magnitude 100000)&quot; &quot;(defn compare-magnitude\n  [a b]\n  (neg? (- (magnitude a) (magnitude b))))&quot; &quot;(def comparator-magnitued (comparator compare-magnitude))&quot; &quot;#(or (not  (nil? %)) (true? %))&quot; &quot;(def logic-true #(and  (not  (nil? %)) (true? %)))&quot; &quot;(def logic-true #(and  (not  (nil? %)) (not (false? %))))&quot; &quot;(logic-true \&quot;da\&quot;)&quot; &quot;(false? \&quot;dd\&quot;)&quot; &quot;(nil? \&quot;dd\&quot;)&quot; &quot;[(odd? [n]\n              (even? (dec n)))\n        (even? [n]\n               (or (zero? n)\n                   (odd? (dec n))))]&quot; &quot;(letfn [(odd? [n]\n              (even? (dec n)))\n        (even? [n]\n               (or (zero? n)\n                   (odd? (dec n))))]\n  (even? 4))&quot; &quot;(letfn [(odd? [n]\n              (even? (dec n)))\n        (even? [n]\n               (or (zero? n)\n                   (odd? (dec n))))]\n  (even? 5))&quot; &quot;[(odd? [n]\n              (if (zero? n)\n                false\n                (even? (dec n))))\n        (even? [n]\n               (or (zero? n)\n                   (odd? (dec n))))]&quot; &quot;(letfn [(odd? [n]\n              (if (zero? n)\n                false\n                (even? (dec n))))\n        (even? [n]\n               (or (zero? n)\n                   (odd? (dec n))))])&quot; &quot;(odd? 11)&quot; &quot;(odd? 12)&quot; &quot;(letfn [(odd? [n]\n              (if (zero? n)\n                false\n                (even? (dec n))))\n        (even? [n]\n               (or (zero? n)\n                   (odd? (dec n))))]\n  (odd? 11))&quot; &quot;(letfn [(odd? [n]\n              (if (zero? n)\n                false\n                (even? (dec n))))\n        (even? [n]\n               (or (zero? n)\n                   (odd? (dec n))))]\n  (odd? 12))&quot; &quot;(comparator-magnitued 10 10000)&quot; &quot;(comparator-magnitued 10000 10)&quot; &quot;(compare-magnitude 10 66)&quot; &quot;(comparator-magnitued 10 66)&quot; &quot;(conj *1 750)&quot; &quot;((defn compare-magnitude\n  [a b]\n  ((let [diff (- (magnitude a) (magnitude b))]\n    (if (zero? diff)\n      (compare a b)\n      diff)))))&quot; &quot;(defn compare-magnitude\n  [a b]\n  ((let [diff (- (magnitude a) (magnitude b))]\n    (if (zero? diff)\n      (compare a b)\n      diff))))&quot; &quot;(defn compare-magnitude\n  [a b]\n  (let [diff (- (magnitude a) (magnitude b))]\n    (if (zero? diff)\n      (compare a b)\n      diff)))&quot; &quot;(contains? *1 1239)&quot; &quot;(sorted-set-by compare-magnitude 10 1000 500)&quot; &quot;(conj *1 600)&quot; &quot;(disj *1 750)&quot; &quot;(subseq ss &gt; 500)&quot; &quot;(subseq ss &gt; 670)&quot; &quot;(subseq ss &gt; 699)&quot; &quot;(subseq ss &gt; 670 &lt;= 1000)&quot; &quot;(rsubseq ss &gt;500 &lt;= 1000)&quot; &quot;(rsubseq ss &gt; 500 &lt;= 1000)&quot; &quot;(def m (into (sorted-map) (map vec [[0 0] [10 10] [15 5]])))&quot; &quot;m&quot; &quot;(subseq m &lt;= [2 10 12])&quot; &quot;(subseq m &lt;= 2)&quot; &quot;(rsubseq m &lt;= 2)&quot; &quot;(subseq m &gt; 2)&quot; &quot;(sorted-set-by compare-magnitude 10 1000 500 670 1239)&quot; &quot;(def ss *1)&quot; &quot;(subseq ss &gt; 669)&quot; &quot;(defn interpolate\n  \&quot;take a collection of points,return a function which is a linear interpolation between those points.\&quot;\n  [points]\n  (let [results (into (sorted-map) (map vec points))]\n    (fn [x]\n      (let [[xa ya] (first (rsubseq results &lt;= x))\n            [xb yb] (first (subseq results &gt; x))]\n        (if (and xa xb)\n          (/ (+ (* ya (- xb x)) (* yb (- x xa)))\n             (- xb xa))\n          (or ya yb))))))&quot; &quot;(def f (interpolate [[0 0] [10 10] [15 5]]))&quot; &quot;(map f [2 10 12])&quot; &quot;(defn swap-pairs\n  [sequential]\n  (into (empty sequential)\n        (interleave\n          (take-nth 2 (drop 1 sequential))\n          (take-nth 2 sequential))))&quot; &quot;(swap-pairs (range 10))&quot; &quot;(defn map-map\n  [f m]\n  (into (empty m)\n        (for [[k v] m]\n        [k (f v)])))&quot; &quot;(map-map inc (hash-map :a 3 :b 5))&quot; &quot;(hash-map :a 3 :b 5)&quot; &quot;(get [:a :b :C] 2)&quot; &quot;(get #{1 2 3} 3)&quot; &quot;([:a :b :C] 2)&quot; &quot;({:a 5 :b 6} :b)&quot; &quot;({:a 5 :b 6} :c 7)&quot; &quot;([:a :b :C] 4)&quot; &quot;([:a :b :C] -1)&quot; &quot;(#{1 2 3} 3)&quot; &quot;(get #{:a :b :c} :d)&quot; &quot;(get {:a 5 :b 6} :c 7)&quot; &quot;(get {:a 5 :b 6} :b)&quot; &quot;(:b {:a 5 :b 6} )&quot; &quot;(:c {:a 5 :b 6} 7)&quot; &quot;(:d {:a 5 :b 6})&quot; &quot;(:d #{:a :b :c})&quot; &quot;(defn get-foo\n  [map]\n  (:foo map))&quot; &quot;(get-foo nil)&quot; &quot;(defn get-bar\n  [map]\n  (map :bar))&quot; &quot;(get-bar nil)&quot; &quot;(some #{1} [1 2 3])&quot; &quot;(map :name [{:age 21 :name \&quot;David\&quot;}\n            {:gender :f :name \&quot;Suzanne\&quot;}\n            {:name \&quot;Sara\&quot; :location \&quot;NYC\&quot;}])&quot; &quot;(some #{1 3 7} [0 2 4 5 6])&quot; &quot;(some #{1 3 7} [0 2 3 4 5 6])&quot; &quot;(filer :age [{:age 21 :name \&quot;David\&quot;}\n            {:gender :f :name \&quot;Suzanne\&quot;}\n            {:name \&quot;Sara\&quot; :location \&quot;NYC\&quot;}])&quot; &quot;(filter :age [{:age 21 :name \&quot;David\&quot;}\n            {:gender :f :name \&quot;Suzanne\&quot;}\n            {:name \&quot;Sara\&quot; :location \&quot;NYC\&quot;}])&quot; &quot;(filter (comp (partial &lt;= 25) :age)  [{:age 21 :name \&quot;David\&quot;}\n             {:gender :f :name \&quot;Suzanne\&quot; :age 20}\n             {:name \&quot;Sara\&quot; :location \&quot;NYC\&quot; :age 34}])&quot; &quot;(renmove #{5 7} (conj false (range 10)))&quot; &quot;(remove #{5 7} (conj false (range 10)))&quot; &quot;(remove #{5 7} (cons false (range 10)))&quot; &quot;(partial contains? #{5 7 false} (cons false (range 10)))&quot; &quot;(remove (partial contains? #{5 7 false} (cons false (range 10))))&quot; &quot;(cons false (range 10))&quot; &quot;(remove #{5 7 false} (cons false (range 10)))&quot; &quot;(remove (partial contains? #{5 7 false}) (cons false (range 10)))&quot; &quot;(defn reduce-by\n  [key-fn f init coll]\n  (reduce (fn [summaries x]\n            (let [k (key-fn x)]\n              (assoc summaries k (f (summaries k init) x))))\n  {} coll))&quot; &quot;(reduce-by #(rem % 3) #{} (range 10))&quot; &quot;(reduce-by #(rem % 3) inc 0 (range 10))&quot; &quot;(reduce-by #(rem % 3) #(+ %1 %2) 0 (range 10))&quot; &quot;({} 1 2)&quot; &quot;({} inc [1 2])&quot; &quot;({0 0} 1 0)&quot; &quot;({0 1} 1 0)&quot; &quot;({0 1} 1 31)&quot; &quot;({1 2} 1 3)&quot; &quot;'@x&quot; &quot;''x&quot; &quot;'#(+ % %)&quot;], :remote []}}</component>
</project>