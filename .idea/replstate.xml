<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1445907000884">{:repl-history {:ide [], :local [&quot;(*out*-logger \&quot;hello\&quot;)&quot; &quot;(def writer (java.io.StringWriter.))&quot; &quot;(def retained-logger (print-logger writer))&quot; &quot;(retained-logger \&quot;hehe\&quot;)&quot; &quot;(str writer)&quot; &quot;(require 'clojure.java.io)&quot; &quot;((defn file-logger\n  \&quot;docstring\&quot;\n  [file]\n  #(with-open [f (clojure.java.io/writer file :append true)]\n    ((print-logger f) %))))&quot; &quot;(defn file-logger\n  \&quot;docstring\&quot;\n  [file]\n  #(with-open [f (clojure.java.io/writer file :append true)]\n    ((print-logger f) %)))&quot; &quot;(def log-&gt;file (file-logger \&quot;message.log\&quot;))&quot; &quot;(log-&gt;file \&quot;hoho\&quot;)&quot; &quot;(log-&gt;file \&quot;dad\&quot;)&quot; &quot;(format \&quot;[%1$tY]\&quot; (java.util.Date.) \&quot;dad\&quot;)&quot; &quot;(*out*-logger (format \&quot;[%1$tY]\&quot; (java.util.Date.) \&quot;dad\&quot;))&quot; &quot;(*out*-logger (format \&quot;[%1$tY]\&quot;(java.util.Date.) \&quot;dad\&quot;))&quot; &quot;(*out*-logger (format \&quot;[%1$tY]\&quot; (Date.)\&quot;dad\&quot;))&quot; &quot;(*out*-logger (format \&quot;[%1$tY]\&quot; (Date.) \&quot;dad\&quot;))&quot; &quot;(*out*-logger (str (format \&quot;[%1$tY]\&quot; (Date.) \&quot;dad\&quot;)))&quot; &quot;(*out*-logger (+ (format \&quot;[%1$tY]\&quot; (Date.)) \&quot;dad\&quot;))&quot; &quot;(*out*-logger (str (format \&quot;[%1$tY]\&quot; (Date.)) \&quot;dad\&quot;))&quot; &quot;(log-&gt;file \&quot;qeqe\&quot;)&quot; &quot;(defn muti-logger\n  [&amp; loggers]\n  #(doseq [f loggers]\n    (f %)))&quot; &quot;(muti-logger *out*-logger log-&gt;file)&quot; &quot;(def log (muti-logger *out*-logger log-&gt;file))&quot; &quot;(log \&quot;nn\&quot;)&quot; &quot;(defn timestamped-logger\n  [logger]\n  #(logger (format \&quot;[%1$tY-%1$tm-%1$te %1$tH:%1$tM:%1$tS] %2$s\&quot;) (Date.) %))&quot; &quot;(defn timestamped-logger\n  [logger]\n  #(logger (format \&quot;[%1$tY-%1$tm-%1$te %1$tH:%1$tM:%1$tS] %2$s\&quot;  (Date.) %)))&quot; &quot;((timestamped-logger *out*-logger) 12)&quot; &quot;(def log-timestamped (timestamped-logger log))&quot; &quot;(log-timestamped \&quot;pp\&quot;)&quot; &quot;(require 'clojure.xml)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :rss)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :link)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :link\n     print)&quot; &quot;(-&gt;&gt; (str \&quot;http://weather.yahooapis.com/forecastrss?w=2151330&amp;u=c\&quot;)\n     clojure.xml/parse\n     :content\n     print)&quot; &quot;(defn prime?\n  [n]\n  (cond\n    (== 1 n) false\n    (==2 n) true\n    (even? n) false\n    :else (-&gt;&gt; (range 3 (inc (Math/sqrt n)) 2)\n               (filter #(zero? (rem n %)))\n               empty?)))&quot; &quot;(defn prime?\n  [n]\n  (cond\n    (== 1 n) false\n    (== 2 n) true\n    (even? n) false\n    :else (-&gt;&gt; (range 3 (inc (Math/sqrt n)) 2)\n               (filter #(zero? (rem n %)))\n               empty?)))&quot; &quot;(prime? 14141)&quot; &quot;(prime? 5)&quot; &quot;(prime? 112589990)&quot; &quot;(prime? 1125899906842679)&quot; &quot;(time  (prime? 1125899906842679))&quot; &quot;(let [m-prime? (memoize prime?)])&quot; &quot;(time  (m-prime? 1125899906842679))&quot; &quot;(let [m-prime? (memoize prime?)]\n(time (m-prime? 1125899906842679)))&quot; &quot;(let [m-prime? (memoize prime?)]\n(time (m-prime? 1125899906842679))\n(time (m-prime? 1125899906842679)))&quot; &quot;(rand-int 1)&quot; &quot;(rand-int 2)&quot; &quot;(conj v 4)&quot; &quot;(conj v 4 5)&quot; &quot;(seq v)&quot; &quot;(def m {:a 4 :b 5})&quot; &quot;(conj s 4)&quot; &quot;(seq m)&quot; &quot;(conj m [:c 6])&quot; &quot;(seq s)&quot; &quot;#{2 1 3}&quot; &quot;#{1 2 3}&quot; &quot;(conj s 3 4)&quot; &quot;#{1 2 3 4}&quot; &quot;#{1 2 3 46}&quot; &quot;(def s #{1 3 4})&quot; &quot;(conj s 2)&quot; &quot;(def s #{1 2 3})&quot; &quot;(conj s 10)&quot; &quot;(seq lst)&quot; &quot;(conj lst 0 -1)&quot; &quot;(into v [4 5])&quot; &quot;(into v [3 4])&quot; &quot;(into m [[c: 7] [:d 8]])&quot; &quot;(into m [[:c 7] [:d 8]])&quot; &quot;(into s [3 4])&quot; &quot;(into  lst [4 5])&quot; &quot;(into  lst [[:a 1]] )&quot; &quot;(into  [1] [[:a 1]] )&quot; &quot;(conj v {:a 2})&quot; &quot;(into  [1] {:a 1} )&quot; &quot;(swap-pairs [1 2 4 5])&quot; &quot;(interleave\n          (take-nth 2 (drop 1 sequential))\n          (take-nth 2 sequential))&quot; &quot;(take-nth 2 sequential)&quot; &quot;(into (empty sequential)\n        (interleave\n          (take-nth 2 (drop 1 sequential))\n          (take-nth 2 sequential)))&quot; &quot;(defn swap-pairs\n  [sequential]\n  (into (empty sequential)\n        (interleave\n          (take-nth 2 (drop 1 sequential))\n          (take-nth 2 sequential))))&quot; &quot;(apply list (range 10))&quot; &quot;(swap-pairs (apply list (range 10)))&quot; &quot;(swap-pairs (apply vec (range 10)) )&quot; &quot;(swap-pairs (apply vector (range 10)))&quot; &quot;(swap-pairs (range 10))&quot; &quot;(take-nth 3 (range 10))&quot; &quot;(range 10)&quot; &quot;(take-nth 2 (range 10))&quot; &quot;(into (empty m)\n        (for [[k v] m] \n        [k (f v)]))&quot; &quot;(defn map-map\n  [f m]\n  (into (empty m)\n        (for [[k v] m] \n        [k (f v)])))&quot; &quot;(map-map inc {:a 1 :b 2})&quot; &quot;(map-map inc (sorted-map :a 3 :b 5))&quot; &quot;(map-map inc (hash-map :a 3 :b 5))&quot; &quot;(count (1 2 4 5))&quot; &quot;(count '(1 2 4 5))&quot; &quot;(count #(1 2 4 5))&quot; &quot;(count #{1 2 4 5})&quot; &quot;(count {:a 1 :b 2 :C 4 :d 5})&quot; &quot;(count [1 2 4 5])&quot;], :remote []}}</component>
</project>