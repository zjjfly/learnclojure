<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1489422665225">{:repl-history {:ide [], :local [&quot;(contains? v 1)&quot; &quot;(contains? v 2)&quot; &quot;(contains? v 0)&quot; &quot;:d&quot; &quot;(contains? m :d)&quot; &quot;(contains? s 3)&quot; &quot;(contains? v 3)&quot; &quot;(get \&quot;clojure\&quot; 3)&quot; &quot;(contains? (java.util.HashMap.) 1)&quot; &quot;(get (into-array [1 2 3]) 0)&quot; &quot;(get {:ethl nil} :ethl)&quot; &quot;(find {:ethl nil} :ethl)&quot; &quot;(find {:ethl nil} :r)&quot; &quot;(if-let [[k v] (find {:a 5 :b 6} :a)]\n  (format \&quot;found %s=&gt;%s\&quot; k v)\n  \&quot;not found\&quot;)&quot; &quot;(let [[q r] (euclidia-devision-2 68 9)]\n  (str \&quot;68/9=\&quot; q \&quot;*9+\&quot; r))&quot; &quot;(def point-3d [24 64 -14])&quot; &quot;(apply str (remove (set \&quot;aeiouy\&quot;) \&quot;vowels are  useless\&quot;))&quot; &quot;(defn strx\n       [coll1 coll2]\n       (map #(apply (partial str \&quot;ad-\&quot;) %) (for [x coll1 y coll2] [x y])))&quot; &quot;(strx [0 1 2] #{1 2 3})&quot; &quot;(group-by (juxt :artist :title) playlist)&quot; &quot;(group-by :artist playlist)&quot; &quot;(defn reduce-by\n  \&quot;docstring\&quot;\n  [key-fn f init coll]\n  (reduce (fn [summaries x]\n            (let [k (key-fn x)]\n              (assoc summaries k (f (summaries k init) x))))\n          {} coll))&quot; &quot;(def orders\n  [{:product \&quot;Clock\&quot;, :custom \&quot;Wile Coyote\&quot;, :qty 6, :total 300}\n   {:product \&quot;Dynamite\&quot;, :custom \&quot;Wile Coyote\&quot;, :qty 20, :total 5000}\n   {:product \&quot;Shotgun\&quot;, :custom \&quot;Elmer Fudd\&quot;, :qty 2, :total 800}\n   {:product \&quot;Shells\&quot;, :custom \&quot;Elmer Fudd\&quot;, :qty 4, :total 100}\n   {:product \&quot;Hole\&quot;, :custom \&quot;Wile Coyote\&quot;, :qty 1, :total 1000}\n   {:product \&quot;Anvil\&quot;, :custom \&quot;Elmer Fudd\&quot;, :qty 2, :total 300}\n   {:product \&quot;Anvil\&quot;, :custom \&quot;Wile Coyote\&quot;, :qty 6, :total 900}\n   ])&quot; &quot;(def orders\n  [{:product \&quot;Clock\&quot;, :customer \&quot;Wile Coyote\&quot;, :qty 6, :total 300}\n   {:product \&quot;Dynamite\&quot;, :customer \&quot;Wile Coyote\&quot;, :qty 20, :total 5000}\n   {:product \&quot;Shotgun\&quot;, :customer \&quot;Elmer Fudd\&quot;, :qty 2, :total 800}\n   {:product \&quot;Shells\&quot;, :customer \&quot;Elmer Fudd\&quot;, :qty 4, :total 100}\n   {:product \&quot;Hole\&quot;, :customer \&quot;Wile Coyote\&quot;, :qty 1, :total 1000}\n   {:product \&quot;Anvil\&quot;, :customer \&quot;Elmer Fudd\&quot;, :qty 2, :total 300}\n   {:product \&quot;Anvil\&quot;, :customer \&quot;Wile Coyote\&quot;, :qty 6, :total 900}\n   ])&quot; &quot;(reduce-by :custom #(+ %1 (:total %2)) 0 orders)&quot; &quot;(reduce-by :customer #(+ %1 (:total %2)) 0 orders)&quot; &quot;(reduce-by :product #(+ %1 (:qty %2)) 0 orders)&quot; &quot;(reduce-by :product #(conj %1 (:customer %2)) [] orders)&quot; &quot;(fn [order]\n  [(:customer order) (:product order)])&quot; &quot;#(vector (:customer %) (:product %))&quot; &quot;(juxt :customer :product)&quot; &quot;(fn [{:keys [customer product]}]\n  [customer product])&quot; &quot;(reduce-by (juxt :customer :product) #(+ %1 (:total %2)) 0 orders)&quot; &quot;(defn reduce-by-in\n  [key-fn f init coll]\n  (reduce (fn [summaries x]\n            (let [ks (key-fn x)]\n              (assoc-in summaries ks (f (get-in summaries ks init) x))))\n          {} coll))&quot; &quot;(defn reduce-by-in\n  [key-fn f init coll]\n  (reduce (fn [summaries x]\n            (let [ks (key-fn x)]\n              (assoc-in summaries ks\n                        (f (get-in summaries ks init) x))))\n          {} coll))&quot; &quot;(reduce-by-in (juxt :customer :product) \n              #(+ %1 (:total %2)) 0 orders)&quot; &quot;(def flat-breakup (reduce-by (juxt :customer :product) #(+ %1 (:total %2)) 0 orders)\n  )&quot; &quot;(def flat-breakup \n  (reduce-by (juxt :customer :product) #(+ %1 (:total %2)) 0 orders))&quot; &quot;(apply assoc-in {} [[\&quot;Wile Coyote\&quot; \&quot;Clock\&quot;] 300])&quot; &quot;(conj 1 '(1 2 3))&quot; &quot;(defprotocol Concatenable\n  (cat [this other]))&quot; &quot;(ns learnclojure.chapt3.core9)&quot; &quot;(defprotocol Concatenable\n  (cate [this other]))&quot; &quot;(extend-type String\n  Concatenable\n  (cate [this other])\n  (.concat this other))&quot; &quot;(extend-type String\n  Concatenable\n  (cate [this other]\n    (.concat this other)))&quot; &quot;(cate \&quot;dad\&quot; \&quot;da\&quot;)&quot; &quot;(extend-type java.util.ArrayList\n  Concatenable\n  (cate [this other]\n    (concat this other)))&quot; &quot;java.util.ArrayList&quot; &quot;(instance? (list 1) ArrayList)&quot; &quot;(instance? ArrayList (list 1))&quot; &quot;(ArrayList. 1)&quot; &quot;(ArrayList.)&quot; &quot;(instance? ArrayList (ArrayList.))&quot; &quot;(ArrayList. [1 2 3])&quot; &quot;(instance? ArrayList (ArrayList. [1 2 3]))&quot; &quot;(.cate (ArrayList. [1 2 3]) (ArrayList. [1 2 3]))&quot; &quot;(cate (ArrayList. [1 2 3]) (ArrayList. [1 2 3]))&quot; &quot;(cate [1 2 3] [0])&quot; &quot;([1 2] 0)&quot; &quot;(reduce #(apply assoc-in %1 %2) {} flat-breakup)&quot; &quot;(apply println (1 2 3))&quot; &quot;(apply + (1 2 3))&quot; &quot;(apply + '(1 2 3))&quot; &quot;(apply println '(1 2 3))&quot; &quot;'(1 2 3)&quot; &quot;(apply println #(1 2 3))&quot; &quot;(apply println [1 2 3])&quot; &quot;(list* 1 2 3)&quot; &quot;(list* (1 2 3))&quot; &quot;(list* 1 3 4)&quot; &quot;(list* '(1 3))&quot; &quot;(list* (1 2))&quot; &quot;(conj '(1 2 3) 0)&quot; &quot;(apply + [1 2 3])&quot; &quot;(+ 1 1)&quot; &quot;(def v (vec (range 1e6)))&quot; &quot;(+ 1 2)&quot; &quot;(chan)&quot; &quot;(def v2 (conj v 1e6))&quot; &quot;(count v2)&quot; &quot;(count v)&quot; &quot;(defn isodate-to-millis-since-epoch\n  \&quot;\&quot;\n  [x]\n  (.getMillis (apply date-time\n                     (map #(Integer/parseInt %) (.split x \&quot;-\&quot;)))))&quot; &quot;(defn name\n  \&quot;docstring\&quot;\n  [arglist]\n apply #(- %1 1) 2)&quot; &quot;(defn name\n  \&quot;docstring\&quot;\n  [arglist]\n apply #(- %1 1) (2))&quot; &quot;(defn name\n  [arglist]\n apply #(- %1 1) (2))&quot; &quot;(name 1)&quot; &quot;(name 1 2)&quot; &quot;(defn test\n  [arglist]\n apply #(- %1 1) (2))&quot; &quot;(defn test1\n  [arglist]\n apply #(- %1 1) (2))&quot; &quot;(test1 1 2)&quot; &quot;(test1 [1])&quot; &quot;(defn test1\n  [arglist]\n apply #(- %1 1) [1])&quot; &quot;(defn test1\n  [arglist]\n (apply #(- %1 1) 2))&quot; &quot;(defn test1\n  [arglist]\n (apply #(- %1 1) (2)))&quot; &quot;(defn test1\n  [arglist]\n (apply #(- % 1) (2)))&quot; &quot;(defn test1\n  [arglist]\n (apply #(- % 1) 2))&quot; &quot;(defn test1\n  [arglist]\n (apply - (1 2)))&quot; &quot;(test1)&quot; &quot;(defn test1\n  [arglist]\n (apply + (1 2)))&quot; &quot;(defn test1\n  [arglist]\n (apply + '(1 2)))&quot; &quot;(test1 1)&quot;], :remote []}}</component>
</project>